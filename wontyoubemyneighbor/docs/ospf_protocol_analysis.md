# OSPF Protocol Analysis - RFC 2328

## Document Purpose
Deep analysis of RFC 2328 (OSPF Version 2) to guide implementation of wontyoubemyneighbor agent.

---

## 1. OSPF Packet Types (RFC 2328 Section 4.3)

### 1.1 Hello Packet (Type 1)
**Purpose**: Discover and maintain neighbor relationships
**Frequency**: Every HelloInterval (default 10 seconds)
**Destination**: AllSPFRouters multicast (224.0.0.5)

**Key Fields**:
- Network Mask: Subnet mask of sending interface
- Hello Interval: Seconds between Hello packets
- Router Priority: For DR/BDR election
- Router Dead Interval: Time before declaring neighbor down (default 40 seconds)
- Designated Router: Current DR IP address
- Backup Designated Router: Current BDR IP address
- Neighbor List: Router IDs of neighbors from which Hellos have been seen

**Implementation Requirements**:
- Send Hello packets on HelloInterval timer
- Process received Hellos to discover neighbors
- Validate Hello packet parameters match (network mask, intervals, area)
- Maintain neighbor list in sent Hellos

### 1.2 Database Description Packet (Type 2)
**Purpose**: Summarize database contents during adjacency formation
**Used In**: ExStart, Exchange states

**Key Fields**:
- Interface MTU: Maximum transmission unit
- Options: OSPF options
- I-bit (Init): First packet in exchange
- M-bit (More): More DBD packets to follow
- MS-bit (Master/Slave): Master=1, Slave=0
- DD Sequence Number: For sequencing packets
- LSA Headers: Summary of LSAs in sender's database

**Implementation Requirements**:
- Determine master/slave based on router ID comparison
- Master initiates exchange with highest sequence number
- Slave responds with master's sequence number
- Exchange all LSA headers from LSDB
- Transition to Loading when exchange complete

### 1.3 Link State Request Packet (Type 3)
**Purpose**: Request specific LSAs from neighbor
**Used In**: Loading state

**Key Fields**:
- List of LSA identifiers (LS Type, Link State ID, Advertising Router)

**Implementation Requirements**:
- Build request list from DBD exchange (LSAs we need)
- Send LSR for missing or outdated LSAs
- Transition to Full when all requests satisfied

### 1.4 Link State Update Packet (Type 4)
**Purpose**: Flood LSAs throughout area
**Contains**: Full LSAs (not just headers)

**Key Fields**:
- Number of LSAs
- List of LSAs (full content)

**Implementation Requirements**:
- Respond to LSR with LSU containing requested LSAs
- Flood new/updated LSAs to all neighbors except sender
- Add received LSAs to LSDB if newer
- Acknowledge with LSAck

### 1.5 Link State Acknowledgment Packet (Type 5)
**Purpose**: Explicitly acknowledge LSAs
**Contains**: LSA headers only

**Implementation Requirements**:
- Send LSAck for received LSUs
- Remove acknowledged LSAs from retransmission list
- Handle delayed vs immediate acknowledgments

---

## 2. Neighbor States (RFC 2328 Section 10.1)

### State Machine Diagram
```
Down -> Init -> 2-Way -> ExStart -> Exchange -> Loading -> Full
  ^                                                           |
  |___________________________________________________________|
                    (InactivityTimer, KillNbr)
```

### 2.1 Down
- Initial state
- No recent Hello received from neighbor
- Hellos not yet being sent to neighbor

### 2.2 Attempt (NBMA networks only)
- Actively attempting to establish neighbor on NBMA network
- Not applicable for broadcast/point-to-point networks

### 2.3 Init
- Hello received from neighbor
- But our Router ID not in neighbor's Hello packet
- Indicates one-way communication

### 2.4 2-Way
- Bidirectional communication established
- Our Router ID appears in neighbor's Hello packet
- DR/BDR election occurs in this state
- Decision point: form adjacency or stay at 2-Way

**Adjacency Decision** (RFC 2328 Section 10.4):
- Always form adjacency on point-to-point/point-to-multipoint
- On broadcast/NBMA: only with DR and BDR
- All other neighbors stay at 2-Way

### 2.5 ExStart
- Establishing master/slave relationship for DBD exchange
- Master: Router with higher Router ID
- Slave: Router with lower Router ID
- Master determines DD sequence number

### 2.6 Exchange
- Exchanging Database Description packets
- Describing entire LSDB via LSA headers
- Building Link State Request list for missing/outdated LSAs

### 2.7 Loading
- Requesting needed LSAs via LSR packets
- Receiving requested LSAs via LSU packets
- Processing received LSAs and adding to LSDB

### 2.8 Full
- Neighbors fully adjacent
- LSDBs synchronized
- Participate in flooding
- Used for SPF calculation

**Implementation Note**: Only Full and 2-Way neighbors are used in routing calculations.

---

## 3. LSA Types (RFC 2328 Section 12.1)

### 3.1 Router LSA (Type 1)
**Generated By**: Every router for each area
**Flooded Within**: Single area
**Contents**: Router's active interfaces and neighbors

**Link Types**:
1. Point-to-point connection to another router
2. Connection to transit network (has DR)
3. Connection to stub network
4. Virtual link

**Implementation Priority**: HIGH (required for basic functionality)

### 3.2 Network LSA (Type 2)
**Generated By**: Designated Router
**Flooded Within**: Single area
**Contents**: All routers attached to multi-access network

**Implementation Priority**: MEDIUM (needed for broadcast networks)

### 3.3 Summary LSA - Network (Type 3)
**Generated By**: Area Border Router (ABR)
**Purpose**: Advertise inter-area destinations
**Flooded Within**: Single area

**Implementation Priority**: LOW (not needed for single area)

### 3.4 Summary LSA - ASBR (Type 4)
**Generated By**: Area Border Router (ABR)
**Purpose**: Advertise location of ASBR
**Flooded Within**: Single area

**Implementation Priority**: LOW (not needed if no external routes)

### 3.5 AS External LSA (Type 5)
**Generated By**: Autonomous System Boundary Router (ASBR)
**Purpose**: Advertise external destinations
**Flooded**: Throughout AS (except stub areas)

**Implementation Priority**: LOW (focus on internal routes first)

---

## 4. Authentication (RFC 2328 Section D)

### 4.1 Null Authentication (Type 0)
- No authentication
- 64-bit auth field not used
**Implementation Priority**: HIGH (simplest, implement first)

### 4.2 Simple Password (Type 1)
- 64-bit clear text password
- Not secure, but simple
**Implementation Priority**: MEDIUM

### 4.3 Cryptographic Authentication (Type 2)
- MD5 hash of packet + secret key
- Secure authentication
**Implementation Priority**: LOW (complex, implement later)

---

## 5. OSPF Header Format (All Packets)

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Version #   |     Type      |         Packet length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Router ID                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Area ID                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |             AuType            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Authentication                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Authentication                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Size**: 24 bytes
**Version**: 2 (OSPF Version 2)
**Type**: 1-5 (packet types)
**Router ID**: Originating router's ID
**Area ID**: Area this packet belongs to
**Checksum**: Standard IP checksum (RFC 905)
**AuType**: 0=Null, 1=Simple, 2=Cryptographic

---

## 6. Timers (RFC 2328 Appendix B)

### 6.1 HelloInterval
**Default**: 10 seconds
**Purpose**: Frequency of Hello packet transmission
**Must Match**: Between neighbors on same network

### 6.2 RouterDeadInterval
**Default**: 40 seconds (4 × HelloInterval)
**Purpose**: Time before declaring neighbor dead
**Must Match**: Between neighbors on same network

### 6.3 RxmtInterval
**Default**: 5 seconds
**Purpose**: Time between LSA retransmissions
**Configurable**: Per interface

### 6.4 InfTransDelay
**Default**: 1 second
**Purpose**: Estimated time to transmit LSA on interface
**Used For**: Incrementing LS Age when flooding

### 6.5 SPF Delay
**Recommended**: 1-5 seconds after topology change
**Purpose**: Avoid excessive SPF calculations
**Strategy**: Exponential backoff for stability

---

## 7. Flooding Procedure (RFC 2328 Section 13)

### 7.1 LSA Comparison (Section 13.1)
Determine which LSA instance is more recent:

1. **Sequence Number**: Higher is newer
   - Initial: 0x80000001
   - Max: 0x7FFFFFFF
   - Wraps at max

2. **Checksum**: If seq numbers equal, higher checksum is newer

3. **Age**: If seq and checksum equal, check age
   - MaxAge (3600s) always newest
   - Age difference > MaxAgeDiff (900s) determines newer

### 7.2 Flooding Steps

1. **Receive LSU**: Extract LSAs from LSU packet

2. **Validate**: Check LS checksum, validate fields

3. **Lookup in LSDB**: Check if we have this LSA

4. **Compare**: Determine if received LSA is newer

5. **Install**: If newer, install in LSDB

6. **Flood**: Send LSU to all interfaces except receiving interface
   - Only flood to Full neighbors
   - Add to retransmission list
   - Remove from retransmission list upon ACK

7. **Acknowledge**: Send LSAck back to sender

### 7.3 Retransmission
- Maintain retransmission list per neighbor
- Retransmit unacknowledged LSAs every RxmtInterval
- Remove from list upon receiving ACK
- Stop retransmitting after MaxAge

---

## 8. Link State Database (RFC 2328 Section 12)

### 8.1 LSDB Structure
**Organization**: Per area
**Indexed By**: (LS Type, Link State ID, Advertising Router)
**Contents**: All LSAs for the area

### 8.2 LSA Header (20 bytes)
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            LS age             |    Options    |    LS type    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Link State ID                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Advertising Router                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     LS sequence number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         LS checksum           |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 8.3 LSA Aging
- **LS Age**: Incremented each second
- **MaxAge**: 3600 seconds (1 hour)
- **Aging**: All LSAs age in LSDB
- **Refresh**: Originating router refreshes every LSRefreshTime (1800s)
- **Expiration**: LSAs reaching MaxAge are flushed from LSDB

**Implementation**: Background task to age LSAs every second

---

## 9. SPF Calculation (RFC 2328 Section 16)

### 9.1 Dijkstra Algorithm
**Input**: Link State Database
**Output**: Shortest path tree rooted at calculating router
**Result**: Routing table

### 9.2 Algorithm Steps

1. **Initialize**:
   - Root = this router
   - Candidate list = empty
   - Shortest path tree = {root}

2. **Add direct neighbors**:
   - From Router LSAs, add point-to-point links
   - Calculate cost to each

3. **Iterate**:
   - Select vertex with lowest cost from candidates
   - Add to shortest path tree
   - Update candidates with vertex's links
   - Repeat until no candidates remain

4. **Build routing table**:
   - For each destination, record next-hop and cost
   - Derive from shortest path tree

### 9.3 Trigger Events
Run SPF when:
- New adjacency reaches Full state
- Adjacency goes down
- LSA contents change
- LSA reaches MaxAge

### 9.4 SPF Optimization
- **Incremental SPF**: Only recalculate affected portions
- **SPF Throttling**: Limit frequency of calculations
- **Exponential Backoff**: Delay between successive SPFs

**Implementation**: Use NetworkX library for Dijkstra calculation

---

## 10. Implementation Priorities

### Phase 1 - Core Functionality (Must Have)
1. ✓ OSPF packet structures (Scapy)
2. ✓ Hello protocol
3. ✓ Neighbor state machine (Down → Full)
4. ✓ DBD exchange
5. ✓ LSDB management
6. ✓ LSA flooding (LSR, LSU, LSAck)
7. ✓ Router LSA generation
8. ✓ SPF calculation
9. ✓ Routing table generation

### Phase 2 - Network Types (Nice to Have)
1. Point-to-point networks (priority)
2. Broadcast networks (DR/BDR election)
3. NBMA networks (manual neighbor config)

### Phase 3 - Advanced Features (Future)
1. Network LSA generation (if DR)
2. Multiple areas
3. Virtual links
4. Cryptographic authentication
5. Graceful restart
6. Stub areas
7. NSSA areas

---

## 11. Critical Constants

```python
# Protocol
OSPF_VERSION = 2
OSPF_PROTOCOL_NUMBER = 89  # IP protocol number

# Multicast Addresses
ALLSPFROUTERS = "224.0.0.5"    # All OSPF routers
ALLDROUTERS = "224.0.0.6"      # All DR/BDR routers

# Packet Types
HELLO_PACKET = 1
DATABASE_DESCRIPTION = 2
LINK_STATE_REQUEST = 3
LINK_STATE_UPDATE = 4
LINK_STATE_ACK = 5

# Neighbor States
STATE_DOWN = 0
STATE_ATTEMPT = 1
STATE_INIT = 2
STATE_2WAY = 3
STATE_EXSTART = 4
STATE_EXCHANGE = 5
STATE_LOADING = 6
STATE_FULL = 7

# LSA Types
ROUTER_LSA = 1
NETWORK_LSA = 2
SUMMARY_LSA_NETWORK = 3
SUMMARY_LSA_ASBR = 4
AS_EXTERNAL_LSA = 5

# Timers (seconds)
HELLO_INTERVAL = 10
ROUTER_DEAD_INTERVAL = 40
RETRANSMIT_INTERVAL = 5
INF_TRANS_DELAY = 1
LS_REFRESH_TIME = 1800
MAX_AGE = 3600

# Sequence Numbers
INITIAL_SEQUENCE_NUMBER = 0x80000001
MAX_SEQUENCE_NUMBER = 0x7FFFFFFF
```

---

## 12. Key Implementation Decisions

### 12.1 Network Type
**Decision**: Start with point-to-point
**Rationale**: Simplest, no DR/BDR election needed
**Future**: Add broadcast network support

### 12.2 Authentication
**Decision**: Start with Null authentication
**Rationale**: Focus on protocol mechanics first
**Future**: Add MD5 authentication

### 12.3 Area Support
**Decision**: Single area (Area 0) only
**Rationale**: Sufficient for initial implementation
**Future**: Add multi-area support with ABR functionality

### 12.4 LSA Types
**Decision**: Router LSA (Type 1) only initially
**Rationale**: Minimum required for routing
**Future**: Add Network LSA for DR functionality

### 12.5 Programming Model
**Decision**: Asyncio event-driven architecture
**Rationale**:
- Multiple concurrent tasks (Hello send, receive loop, timers)
- Non-blocking I/O for network operations
- Clean timer management
- Natural fit for OSPF's event-driven nature

---

## 13. Testing Strategy

### 13.1 Unit Tests
- Packet parsing/generation
- State machine transitions
- LSDB operations
- SPF algorithm

### 13.2 Integration Tests
- Hello exchange with real router
- Adjacency formation
- LSA flooding
- Complete end-to-end flow

### 13.3 Validation
- Wireshark captures of OSPF packets
- Verify packet format compliance
- Check router neighbor output
- Verify route advertisement

---

## Summary

RFC 2328 defines a complex, stateful protocol with multiple packet types, state machines, and algorithms. Our implementation will:

1. **Start simple**: Point-to-point, single area, null auth
2. **Build incrementally**: Add features in priority order
3. **Test continuously**: Validate against real routers
4. **Focus on correctness**: RFC compliance over optimization
5. **Document thoroughly**: Track design decisions

The protocol is well-defined and testable. Success metric: Form Full adjacency with real router and exchange routes.
